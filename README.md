# Overview

Pied Piper is a team of AI SubAgents that can autonomously or semi-autonomously work on long-running coding tasks with full End-to-end tracking and human-in-the-loop approvals. 

These SubAgents run on Coding Agents, Temporal, Docker, Cloud Desktop etc, so they can work even while you're AFK sleeping or on vacation.

Pied-Piper is meant to be used from within your favourite Coding CLIs like Claude Code etc.

# Getting started

-[ ] Install Pied-Piper

# Development

Pied-piper is built using Go.

To get started with development, you can use the following commands:

```bash
cd $GOPATH/src/github.com/sathish316/pied-piper
git clone https://github.com/sathish316/pied-piper.git
go run main.go
```

To run tests:
```bash
go test -v ./...
```

To build the project:
```bash
go build
```

To install the project:
```bash
go install github.com/sathish316/pied-piper
```

# SDLC Workflow 

A typical SDLC workflow to implement a small feature or fix a bug consists of the following steps:
1. Requirement and Acceptance criteria
2. High level design or architecture
3. Low level design - Data model, API signatures etc
4. Write code (in a feature branch)
5. Write tests
6. Run unit tests to validate the implementation
7. Review code
8. Run unit and integration tests to validate the implementation
9. Create a Pull request for review
10. Merge feature branch to main
11. Rinse and repeat for the next feature or bug fix

The creative work here occurs in both planning what to build and actually building it. Deciding what to build next requires a human. Verifying what is planned/built is what is needed requires a human to review the plan and code. The backlog can be generated by humans.

The role of Pied-Piper SubAgents is to automate the repetitive tasks like writing unit tests, integration tests etc.

Sometimes, Pied-Piper SubAgents can also be used to build minor/major features or bug fixes autonomously or semi-autonomously.

## SubAgent Roles & Responsibilities

Pied-Piper roles are:
* microsprint-orchestrator (Orchestrator): starts microsprint, assigns tasks to subagents, runs the microsprint either autonomously or semi-autonomously, ends microsprint
* product-manager (Planner): defines requirements and acceptance criteria
* architect (Planner): creates plan with high level design and architecture
* software-engineer (Maker): creates plan with low level design and data model, create feature branch,write code, write unit tests, run unit tests
* code-reviewer (Checker): review code in a git commmit, review code in a pull request
* code-validator (Checker): run unit and integration tests to validate the implementation, run quick-check or property based tests if required to validate the implementation
* build-engineer: creates pull request for review, merge feature branch to main if human-engineer approves
* human-engineer (Reviewer): reviews the plan, code, pull-request

## SubAgent Task Management

This project uses beads for Task management by both Agents and Humans.

To know all about beads run:
```
$ bd quickstart
```

SubAgents use git-flow method for every new feature
```
$ git-flow help
```

## SubAgent SDLC Workflow

SDLC Workflow is executed in every microsprint.
Microsprint is an epoch in the SDLC Workflow.

2 Issues are created for a task.
* feature-x: this task is created by human-engineer with the label @open
* plan-feature-x: this task is created by microsprint-orchestrator with the label @ready-for-plan
* build-feature-x: this task is created by microsprint-orchestrator with the label @ready-for-dev

Issues go through the following lifecycle (in auto-approve mode):
* planning
    * @open / @ready-for-plan -> @define-requirement
    * @define-requirement -> @ready-for-hld
    * @ready-for-hld -> @ready-for-lld
    * @ready-for-lld -> @plan-complete -> @closed
* making
    * @open / @ready-for-dev -> @coding-done -> @ready-for-code-review
    * @ready-for-code-review -> @code-review-done -> @ready-for-code-validation
    * @ready-for-code-review -> @code-review-rejected -> @ready-for-code-review
    * @ready-for-code-validation -> @code-validation-done -> @ready-for-merge
    * @ready-for-code-validation -> @code-validation-failed -> @ready-for-code-validation
* shipping
    * @ready-for-merge -> @closed


Issues go through the following lifecycle (in human-approve mode):
* planning
    * @ready-for-lld -> @review-plan -> @approve-plan -> @closed
    * @ready-for-lld -> @review-plan -> @reject-plan -> (@define-requirement | @ready-for-hld | @ready-for-lld)
* making
    * @ready-for-build -> @review-make -> @approve-make -> @closed
    * @ready-for-build -> @review-make -> @reject-make -> @ready-for-dev
* shipping
    * @ready-for-merge -> @closed

## SubAgent routing
Each Subagent responds to the following incoming and outgoing labels:

* microsprint-orchestrator
incoming: @open, @ready-for-plan, @approve-plan, @reject-plan, @approve-make, @reject-make
outgoing: @define-requirement
* product-manager
incoming: @define-requirement
outgoing: @ready-for-hld
* architect
incoming: @ready-for-hld
outgoing: @ready-for-lld
* software-engineer
incoming: @ready-for-lld, @ready-for-dev, @code-review-rejected
outgoing: @ready-for-code-review
* code-reviewer
incoming: @ready-for-code-review
outgoing: @code-review-done, @code-review-rejected
* code-validator
incoming: @ready-for-code-validation, @code-validation-failed
outgoing: @code-validation-done
* build-engineer
incoming: @ready-for-merge
outgoing: @closed
* human-engineer
incoming: @review-plan, @review-make
outgoing: @approve-plan, @approve-make, @reject-plan, @reject-make

## SubAgent Knowledge Management

Subagents have access to a wiki for markdown docs and knowledge management.
Subagents will create separate commits for code and docs.

Each Subagent only reads and creates the following files in each microsprint. Other than docs, SubAgents also deal with a few other artifacts like Tasks, Code etc::
* microsprint-orchestrator:
incoming: plan-feature-x task
outgoing: GOAL_foo.md (where foo is the feature id or task id), build-feature-x task
* product-manager:
incoming: -
outgoing: REQUIREMENT_foo.md (where foo is the feature id or task id)
* architect:
incoming: REQUIREMENT_foo.md
outgoing: HLD_foo.md
* software-engineer:
incoming: HLD_foo.md, LLD_foo.md, build-feature-x task
outgoing: LLD_foo.md, Code
* code-reviewer:
incoming: git_sha..git_sha, Code,
outgoing: Comments in build-feature-x task, Future: Comments in github commit
* code-validator:
incoming: git_sha
outgoing: -
* build-engineer:
incoming: -
outgoing: -
* human-engineer:
incoming: -
outgoing: feature-x task for one or more tasks with specifications. Features can be configured to do plan + build, build only, plan only, bugfixes can be build + test only. By default do both plan + build.


## SubAgent Nicknames

SubAgents have nicknames from the fictional PiedPiper company. You can change the nicknames after the SubAgents are generated. The SubAgents will both respond to roles and nicknames. In case you need to create multiple SubAgents of the same role, giving them different nicknames helps.

* microsprint-orchestrator: "Pied-Piper"
* product-manager: "Jared"
* architect: "Richard"
* software-engineer: "Gilfoyle"
* code-reviewer: "Dinesh"
* code-validator: "Erlich"
* build-engineer: "Jian Yang"
* human-engineer: <Your name>

## Cookbook

### Building a feature with SubAgents

### How to use SubAgents from Claude Code for SDLC Workflow?

Pied-Piper is not directly used by your Coding Agent. It gets out of the way after the SubAgents are created and configured in your coding agents.

**Pied-piper CLI**

#### help
```bash
$ pied-piper help
```

#### create-team
To create a default SDLC team with the name pied-piper
```bash
$ pied-piper team create --default
```

Create your custom team with the name pied-piper
#### create-team
```bash
$ pied-piper team create --name "pied-piper"
```

To create team for a given playbook, you can use the following command:
```bash
$ pied-piper team create --name "pied-piper" --playbook "microservice-to-monolith"
```

#### configure-team
```bash
$ pied-piper team configure --name "pied-piper"
```

teams/pied-piper/team-config.yml

```yml
name: "pied-piper"
subagents:
  - role: "architect"
    nickname: "Richard"
  - role: "software-engineer"
    nickname: "Gilfoyle"
  - role: "code-reviewer"
    nickname: "Dinesh"
  - role: "code-validator"
    nickname: "Erlich"
  - role: "build-engineer"
    nickname: "Jian Yang"
task_workflow:

```

#### add-subagent
If you've already updated subagents in team-config.yml, you can skip this step. Adding a subagent through CLI will update the config file.

```bash
$ pied-piper subagent create --team-name "pied-piper" --role "architect" --nickname "Richard"
```

#### configure-subagents
```bash
$ pied-piper subagent configure --team-name "pied-piper" --role "architect"
$ pied-piper subagent configure --team-name "pied-piper" --role "architect" --nickname "Richard"
```

teams/pied-piper/subagents/architect.yml
```yml
name: "architect"
role: "architect"
nickname: "Richard"
description: "..."
system_prompt: "..."
tools: default # configure in coding CLI
task_labels:
  incoming:
  - @ready-for-hld
  outgoing:
  - @ready-for-lld
wiki_labels:
  incoming:
  - GOAL_foo.md
  outgoing:
  - @ready-for-hld
  - @ready-for-lld
  - @plan-complete
  - @closed
```

#### customize an individual subagent

You can customize subagents either before they are created or after they are created.

To change subagent before generation, edit **teams/<team-name>/subagents/<subagent-name>.yml** file ex: **teams/pied-piper/subagents/architect.yml** file

To change subagent after generation, directly update the Subagents in Claude or Coding CLI.

#### Generate SubAgents

To generate all SubAgents for a team:

```bash
$ pied-piper subagent generate --team-name "pied-piper" --all --for claude-code
```

To generate or update an individual subagent:

```bash
$ pied-piper subagent generate --team-name "pied-piper" --role "architect" --for claude-code
```

**Pied-piper as an MCP server**
Coming Soon...

### How to use SubAgents from other Coding CLIs for SDLC Workflow?

Follow the same steps as above. While generating the subagents, change --for to your Coding CLI. 

Supported Coding CLIs are:
* Claude Code

**Pied-piper CLI**

**Pied-piper as an MCP server**
Coming Soon...

### How to assign a task to SubAgents?

### How to run the SubAgents in Autonomous mode?

### I like the way SubAgents work, but How can I customize them further?

Option 1 - Change the system prompt of SubAgents to suit your requirements

Option 2 - Add instructions to SubAgent memory to follow in the future

### I don't like the way SubAgents work, How can I generate my own set of SubAgents?

### How to monitor the progress of SubAgents?

### How to review and approve the work of SubAgents?

### Can I give nicknames to SubAgents?

### How to assign next task to SubAgents?

### How to control the token cost?

### How to manage wikis generated by SubAgents?

# Continuous Coding / Long-running SDLC Workflows

There are different types of tedious work in software engineering. These are long-running projects that are built over multiple weeks or months, but at the end of the project, you haven't accomplished much or shipped anything of value. These are boring but necessary tasks that need to get done. Some Examples of these are:
1. Migration from library version x to version y - Rails 5 to Rails 8
2. Migration from language x to language y - Python to Typescript
3. Migration from library x to library y - PydanticAI to LangChain
4. Ensure Unit Test coverage is > 80% on repos with little to no coverage
5. Ensure Integration and Behavioural Test coverage is > 80% on repos with little to no coverage
6. Consolidate Microservices to Monolith
7. Change Database or Queueing technology from x to y
8. Fix security vulnerabilities in the codebase
9. Fix static code analysis violations in the codebase

Pied-Piper aims to reduce all this tedious work by automating the repetitive parts of these Long-running workflows.

## Continuous Coding SubAgent Teams and Recipes

Team is a group of SubAgents that are dedicated to a specific long-running project.

Recipe is a workflow for a specific kind of long-running project.

In this repo, you'll find various teams and recipes that you can customize and use for a long running workflow.

### Library version migration recipe

### Language migration recipe

### Library migration recipe

### Unit test coverage improvement recipe

### Integration test coverage improvement recipe

### Microservices to Monolith consolidation recipe

### Database or Queueing technology migration recipe

## Cookbook

# Development

# Release

Release to homebrew

# LICENSE

